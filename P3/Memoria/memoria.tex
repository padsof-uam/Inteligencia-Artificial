\documentclass[nochap]{apuntes}

\usepackage{alltt}
\author{Guillermo Julián y Víctor de Juan}
\date{28-Marzo}
\title{Inteligencia Artificial - Practica 3}

\begin{document}

\section*{Parte B}
\subsection*{Pregunta B1. Función de Evaluación}
\subsubsection*{Apartado B1.1}

Todas nuestras funciones de evaluación seguían el mismo formato. Varios factores dependientes del tablero que podían ser influyentes, ponderados según su importancia.

\subsubsection*{Fundamentos, razonamiento y pruebas}
Tras jugar varias partidas descubrimos factores importantes

\begin{itemize}
\item El número de hoyos ocupados.
\item El máximo de semillas en un hoyo.
\item Cuantos hoyos hay libres.
\item El máximo de semillas que puedo robar (encadenadamente. Contando con que al robar hay que seguir sembrando y se pueden volver a robar)
\item El número de hoyos en los que no nos pueden robar semillas (por tener más de 4 semillas o por no tener ninguna)
\item El número de hoyos en los que si se pueden robar semillas.
\item El número de hoyos con 1 semilla (si tenemos todos los hoyos con una única semilla es muy fácil perder, porque en cuanto nos roben una, siembran y nos roban la siguiente (si el oponente tiene semillas en sus hoyos claro)
\end{itemize}

Estos factores son son computables para ambos jugadores de la partida.

El problema que nos encontramos fue cómo ponderar los dicersos factores. Lo que hemos hecho para resolver este sistema ha sido utilizar un algoritmo de optimización llamado \textit{Simulated-annealing}. El empleo de este algoritmo nos posibilitó encontrar la mejor combinación de ponderaciones para los factores.

\paragraph{Simulated Annealing}
La implementación de este algoritmo se encuentra repartida entre los ficheros \textit{siman.cl} (que contiene el algoritmo general de simmulated annealing) y \textit{simancala.cl} (que es la concreción del algoritmo para partidas de mancala).

El resultado de la ejecución de \textit{simancala.cl} es una lista de números entre -1 y 1. -0.83 significa partida ganada en 17 turnos, y de manera similar, 0.36 significa partida perdida en 0.64. De esta forma cuanto más negativos consigamos mejor. 

No siempre hemos hecho simulaciones con todos los factores (que en el fondo son heurísticas) ya que si obteníamos un peso de 0.000573 en una heurística significa que no es muy importante. 

\paragraph{Pruebas}

Implementamos pequeñas modificaciones en el código recibido para poder tener una función (partida-SA-all-games) que dada una lista de ponderaciones jugara contra los jugadores de referencia \textit{Bueno} y \textit{Regular} a profundidades 1 y 2 (por no emplear demasiado tiempo en la simulación). Para ello fue necesario crear una función de evaluación de cada jugador que también recibiera una lista de ponderaciones aunque luego no la usara y una función de minimax que recibiera como argumento las ponderaciones. Todas estas funciones están agrupadas en el fichero Practica3-SA.cl. 




\subsubsection*{Apartado B1.2}
\subsubsection*{Pruebas de tiempo}
Para medir los tiempos de ejecución de las heurísticas hicimos pruebas del estilo:
\begin{alltt}
(setq mi-posicion (list '(1 0 1 3 3 4 0 3) (reverse '(4 0 3 5 1 1 0 1))))
(setq estado (crea-estado-inicial 0 mi-posicion))
(time (minimax estado 4 'mi-f-eval))
(time (minimax estado 4 'f-eval-Bueno))
\end{alltt}

Y comparando las salidas.

\begin{alltt}
Real time: 0.991875 sec.
Run time: 0.99086 sec.
Space: 11696480 Bytes
GC: 13, GC time: 0.053439 sec.

Real time: 1.322388 sec.
Run time: 1.321234 sec.
Space: 15407168 Bytes
GC: 18, GC time: 0.07669 sec.
\end{alltt}

\subsection*{Pregunta B2. Minimax y Minimax a-b}
\subsubsection*{Apartado B2.1}

\paragraph{Explicación el código entregado:}

Está comparado el código de la función minimax.

\subsubsection*{Apartado B2.2}

\subsubsection*{Apartado B2.3}

\paragraph{Compare el tiempo que tarda un jugador utilizando minimax y utilizando minimax con poda alfa-beta. Comente los resultados.}

La poda tarda mucho menos en el caso de profundidad 2 todas las veces que lo comprobamos. A continuación se muestran los resultados de una ejecución típica:
\begin{alltt}
(time (minimax estado 2 'f-eval-Regular)) 
	; Run time: 0.016814 sec.
(time (minimax-a-b estado 2 'f-eval-Regular)) 
	; Run time: 0.008159 sec.
\end{alltt}

Si aumentamos la profundidad, cada vez se nota menos la diferencia. Inlustramos con 2 ejemplos de ejecuciones lo comentado:

\begin{alltt}
(time (minimax estado 5 'f-eval-Regular)) 
; Run time: 1.279404 sec.
; Run time: 1.293841 sec.

(time (minimax-a-b estado 5 'f-eval-Regular)) 
; Run time: 1.311433 sec.
; Run time: 1.261489 sec.
\end{alltt}

\subsubsection*{Apartado B2.4}
\paragraph{ Modifique el orden el que se exploran las jugadas. Comente el efecto que tiene en la poda alfa-beta modificar dicho orden.}

Con el mismo tablero que en las pruebas anteriores, utilizando la función \textit{aleat-minimax-a-b} (que simplemente hace un \textit{reverse} de la lista de los sucesores) obtenemos unos resultados ligeramente mejores (a pesar de haber tenido que emplear la función reverse que no será un tiempo despreciable por ser de orden O(n)).

Tanto a profundidad 2 como a profundidad 5 se nota la diferencia:


\begin{alltt}
(time (minimax-a-b estado 2 'f-eval-Regular)) 
  ; Run time: 0.015907 sec.
  ; Run time: 0.015142 sec.
  ; Run time: 0.015485 sec.
  ; Run time: 0.010236 sec.


(time (aleat-minimax-a-b estado 2 'f-eval-Regular)) 
  ; Run time: 0.005631 sec.
  ; Run time: 0.005679 sec.
  ; Run time: 0.005685 sec.
  ; Run time: 0.005733 sec.

(time (minimax-a-b estado 5 'f-eval-Regular)) 
  ; Run time: 1.36966 sec.
  ; Run time: 1.348135 sec.
  ; Run time: 1.345875 sec.
  ; Run time: 1.338407 sec.

(time (aleat-minimax-a-b estado 5 'f-eval-Regular)) 
  ; Run time: 1.338015 sec.
  ; Run time: 1.334534 sec.
  ; Run time: 1.333455 sec.
  ; Run time: 1.335938 sec.
\end{alltt}

\subsubsection*{Apartado B2.5}
Si se pudiera ordenar los nodos a explorar de mayor a menor heurística, se podarían siempre todas las opciones menos la primera, el problema es calcular la heurística de todos los sucesores. 

Una posible regla sería ordenar aleatoriamente la lista de sucesores y comprobar qué sucede.


\end{document}