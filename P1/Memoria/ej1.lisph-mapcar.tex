\begin{aibox}{\function}
;; h-mapcar

SYNTAX: h-mapcar (x w sigma) 
\end{aibox}

\begin{aibox}{\examples}
\begin{alltt}
(h-mapcar '(0.1 -0.5 0.7) '() #'tanhip); 0.0
(h-mapcar '(0.1 -0.5 0.7) '(1 2) #'tanhip); -0.7162978
(h-mapcar '(0.1 -0.5 0.7) '(-0.1 0.2 0.3) #'tanhip); 0.09966801
(h-mapcar '(0.1 -0.5 0.7) '(-0.1 0.2 0.3) #'logit); 0.4750208
\end{alltt}
\end{aibox}

\begin{aibox}{\comments}
No hemos incluido las funciones tanhip ni logit ya que son definiciones de expresiones matemáticas ya definidas en el enunciado.
\end{aibox}
\begin{aibox}{\pseudocode}
Pensamos en un pseudocódigo así
\begin{alltt}
h-mapcar (x w sigma)
    para i < longitud(x)
        resultado += sigma(x[i]*w[i])
        i++
\end{alltt}

Aunque luego en lisp no lo implementemos con un bucle, la función \emph{mapcar} nos permite recorrer \emph{x} y \emph{w} de la manera que necesitamos.
\end{aibox}
\begin{aibox}{\code}

\begin{alltt}
(defun h-mapcar (x w sigma) 
    (funcall sigma 
        (reduce #'+
            (mapcar #'* x w))))
\end{alltt}
\end{aibox}
